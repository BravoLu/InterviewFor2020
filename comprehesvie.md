# 后台面经

1. new和malloc的区别
   * new在申请空间的时候会调用构造函数，malloc不会
   * new申请失败时返回bad_alloc（成功时是对象类型指针），malloc返回NULL（成功时是void*）
   * new是C++关键字，需要编译器支持，malloc是库函数，需要加头文件
2. STL
   * set, map：红黑树
   * vector: 数组 list: 链表

3.   Tcp那个字段决定了报文的长度 

   ![pic](C:\Users\bravolu\Desktop\bravolu\tcp.jpg)

4. io多路复用 
   * 同步/异步/阻塞/非阻塞
   * 用户空间/内核空间
   * 进程切换
     * 保存处理机上下文，包括程序计数器和其他寄存器。
     * 更新PCB信息。
     * 把进程的PCB移入相应的队列，如就绪，在某事件阻塞等队列。
     * 选择另一个进程执行，并更新其PCB。
     * 更新内存管理的数据结构。
     * 恢复处理机上下文。
   * 进程的阻塞
   * 文件描述符
   * 缓存IO
     * 操作系统会将IO的数据缓存在文件系统的页缓存中，数据会先被拷贝到操作系统内核缓存区中，然后才会被操作系统内核缓冲区拷贝到应用程序的地址空间。（缺点：数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，开销大）

5. Linux IO模型

   * 网络IO的本质是socket的读取，socket在linux系统被抽象为流，IO可以理解为对流的操作。对于socket流而言，第一步（1）等待网络上的树分组到达，然后被复制到内核的某个缓冲区。（2）把数据从内核缓冲区复制到应用进程缓冲区。

     * 同步IO
     * 阻塞IO
     * 非阻塞IO
     * 多路复用IO
     * 异步IO

     * 同步阻塞IO（在IO执行的两个阶段都被block了）
     * 同步非阻塞IO

6. const与#define相比，有何优点
   * const常量有数据类型，宏常量没有数据类型。编译器可以对前者进行安全检查，对后者没有只进行字符替换，没有类型安全检查，并且可能出现1\*1+1和1\*（1+1）的错误。
7. 寄存器：
   * 保存地址和指令。
   * 寻址/算术&逻辑运算
8. 数组和指针的区别：
   * 修改内容上的差别
   * 用运算符sizeof可以计算数组的容量。数组作为函数的参数进行传递时，数组自动退化为同类型的指针。

9. strcpy，sprintf和memcpy的区别
   * 操作对象不同，strcpy的两个操作对象均为字符串，sprintf的操作对象可以是多种数据类型
   * 执行效率不同，memcpy>strcpy>sprintf
   * 实现功能不同，strcpy主要实现字符串变量间的拷贝，sprintf主要实现其他数据类型到字符串的转化，memcpy主要是内存块间的拷贝。
10. 常量指针和指针常量的区别
    * 常量指针指向常量
    * 指针常量指的是这个指针是常量
11. 三种继承中的访问权限
    * private, public, protected 
    * private: 1.该类的函数 2.友元函数 
    * protected 2. 该类的函数 2.子类的函数 3. 友元函数 
    * public: 1. 该类的函数 2.子类的函数 3. 友元函数 4. 该类的对象
    * 友元函数包括3种：（1）设为友元的普通的非成员函数（2）设为友元的其他类的成员函数（3）设为友元类种的所有成员函数。
12. ping的原理

13. udp如何实现可靠传输：传输层无法保证数据的可靠传输，只能通过应用层来实现。实现的方式参考tcp可靠性传输的方式（1）添加seq/ack （2）添加发送/缓冲区 （3）超时重传

14. 单例模式
    * 单例类只有一个实例。
    * 单例类必须自己创建自己的唯一实例。
    * 单例类必须给所有其他对象提供这一实例。

15. 用户态切换到内核态（1）异常（2）系统调用（3）外部访问中断
    * 系统调用的过程（1）保存CPU寄存器里原来用户态的指令位。（2）执行内核态代码，CPU寄存器需要更新为内核态指令的新位置（3）跳转到内核态运行内核任务（4）当系统调用结束后，CPU寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行。
16. AVL树：平衡二叉查找树
17. HTTP2.0新特性
18. 字节序：大小端
19. select: 在网络编程中统一的操作顺序是创建socket->绑定端口->监听->accept->write/read，当有客户端链接来到时，select会把该链接的文件描述符放到fd_set，然后select会循环遍历它所检测的fd_set内的所有文件描述符，当select循环遍历完所有fd_set内指定的文件描述符对应的poll函数后，如果没有一个资源可用，则select让该进程睡眠，一直等到有资源可用为止，fd_set是一个类似于数组的数据结构，由于它每次都要遍历整个数组，所以她的效率会随着文件描述符的数量增多而变慢。另外，系统还需要把这些描述符集合从内核copy到用户空间，再copy回去，消耗大。
    * select和block I/O其实没有太大不同。事实上，还更差一些。因为这里需要使用两个system call（select和recvfrom)，而blocking I/O只调用了recvfrom。select的优势在于它可以同时处理多个connection.如果连接数不高，使用select/epoll的web server不一定比使用multi-threading+blocking I/O的web server性能更好。
20. epoll: 
21. 排序算法

![pic](C:\Users\bravolu\Desktop\bravolu\sort.jpg)

22. 栈比堆快，因为栈是编译时分配的，堆是动态分配的。
23. 手写单例模式
    * 私有化构造函数
    * 使用类的私有静态指针变量指向类的唯一实现
    * 使用一个公有的静态方法获取实例
24. 简单工厂模式/工厂方法模式/抽象工厂模式

25. 进程切换：
    * 保存处理机上下文，包括程序计数器和其他寄存器
    * 更新PCB信息
    * 把进程的PCB移入相应的队列，如就绪，再某些事件阻塞等待队列
    * 选择另一个进程执行，并更新其PCB
    * 更新内存管理的数据结构
    * 恢复处理机上下文
26. 缓存I/O
    * 缓存I/O又被称为标准I/O，大多数文件系统的默认I/O操作都是缓存I/O。在LINUX的缓存I/O机制中，操作系统会将I/O的数据缓存在文件系统的页缓存（page cache)中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。

27. epoll/select/poll的比较
    * select poll采用轮询方式，epoll采用回调的方式
    * select poll每次等待socket事件，都需要把所有socket从用户态拷贝至内核态，epoll则只需将socket添加一次到红黑树上即可。
    * select用数组来存放socket，因此受到数量限制。poll用链表存放，epoll用红黑树存放，因此不受数量限制。
    * select/poll/epoll虽然都会返回就绪的文件描述符数量，但是select/poll并不会明确指出是哪个文件描述符就绪，而epoll会。造成的区别就是，系统调用返回后，调用select和poll的程序需要遍历监听的整个文件描述符找到是谁处于就绪，而epoll则直接处理即可。
28. 构造函数为什么不能是虚函数
    * vptr是在构造函数中初始化的，如果构造函数为virtual函数，没有vptr指向虚表。
29. folk创建父进程的子进程。
30. 协程是可暂停和恢复执行的过程（过程就是函数）。